# 万物皆对象

这一章节主要内容：

* 对象与引用的关系
* Java中的数据存储分哪几块？基本类型存在哪？数组存在哪？内存占用情况
* static关键字的理解

## 对象与引用的理解

很多时候，我们必须注意将要处理的数据是什么类型。是直接操纵元素，还是用某种基于特殊语法的间接表示(例如C/C++中的指针)来操纵对象。

在Java中很简单，我们记住两个东西：**作为标识符的引用**与这个**标识符指向的对象**。

### 标识符都是引用

Java中的对象创建都存在两种写法：

```java
Person person1 = new Person("小明");

Person person2;
person2 = new Person("小红");
```

* 结论： 如果person1是个对象，那么不需要再通过new来创建对象。因此person1是个用来操纵对象的引用，是一个标识符。Java中用new来创建对象。

可以再看person2的声明，也能证明此结论，正是因为Java中存在这种分两行的写法，很好的诠释了这四步操作：

* 定义一个标识符作为引用。
* 用new创建一个对象。
* ("小明")，调用Person的函数签名为`Person (String)`的构造函数来进行初始化。
* 让引用指向对象。

### 多个引用指向同一对象

```java
Person person3 = person2
```

在以上代码中，将person3的引用指向person引用的对象，此时多个引用指向了同一个对象。

我们可以得到结论：

* 一个引用可以指向0个或1个对象
* 一个对象可以有N个引用指向它。

基于以上的代码，我们再测试：

```java
person3 = new Person("小刚");
person2 = person3;
```

此时，person3这个引用改变了指向的对象，同时，person2也不再指向小红了。

现在的问题在于，小红这个对象呢？

在C/C++中，我们需要释放小红这块内存，在Java中，我们可能会说，小红被Java的垃圾回收机制回收了。

这不准切。确切地说，它已成为垃圾回收机制的处理对象。至于什么时候真正被回收，那要看垃圾回收机制的心情了。

由此看来，下面的语句应该不合法吧？至少是没用的吧？ 

```java
new Person("小明");
```

不对。它是合法的，而且可用的。譬如，如果我们仅仅为了打印而生成一个对象，就不需要用引用变量来系住它。最常见的就是打印字符串：

```java
System.out.println("java");
```

字符串对象“java!”在打印后即被丢弃。有人把这种对象称之为临时对象。

我们可以认为：**对象与引用的关系将持续到对象回收。** 

> Java中存在4种引用，强引用、软引用、弱引用以及虚引用。上述所说的都是强引用，关于其他引用等以后学习JVM的时候再分析吧。



## 数据存储

### 内存模型？

在<<编程思想>>中将数据存储分为5块：寄存器(*registry*)，栈内存(*stack*)，堆内存(*heap*)，常量存储(*Constant storage*)，非RAM(*Non-RAM storage*)存储。读取写入速度依次递减。这里的划分将持久化在另一介质的区域也算进来了(比如磁盘)。

#### 栈

栈有一个另一个名字 -- 虚拟机栈

>  在<<深入理解Java虚拟机>>中，将虚拟机运行时的数据区划分为：
>
> - 方法区，堆
> - 虚拟机栈，本地方法栈
> - 程序计算机

这里的虚拟机栈就是<<编程思想>>中说的栈，更准确的说是虚拟机栈中的局部变量表部分。

什么是虚拟机栈？

虚拟机栈是用于描述java方法执行的内存模型。每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分（栈帧其实就是一个方法执行时所需要数据的结构）。

> 局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同与对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)

以上为局部变量表的存储内容，这应该是对上述的栈内存的准确描述。

书中提到，对于栈(局部变量表)而言，创建程序时，Java 编译器必须准确地知道栈内保存的所有数据的“长度”以及生命周期。也就是说，这些个基本类型以及引用的大小都被确定下来并完成了分配。

注意，**类的成员变量就算有基本类型也会保存在堆中**，**只有方法或者语句块中的局部变量中的基本类型和引用才会放在栈中**。

#### 堆

堆是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

#### 内存计算

基本类型的字节占用与平台(32位 or 64位)无关，内存占用情况如下：

| 基本类型 | 占用内存(bytes) |
| -------- | --------------- |
| boolean  | 1               |
| byte     | 1               |
| short    | 2               |
| char     | 2               |
| int      | 4               |
| float    | 4               |
| long     | 8               |
| double   | 8               |

引用类型在32位上每个占用4bytes，在64位系统上每个占用8bytes，类似于C++中的指针的内存占用。

对于包装类型而言，内存则要乘以8，比如Integer的大小是32字节。 

#### 数组内存

数组由于是一个对象，因此也被分配在了堆上。

## Static关键字的理解

当我们说某些东西是静态的时，它意味着该字段或方法不依赖于任何特定的对象实例 。 即使我们从未创建过该类的对象，也可以调用其静态方法或访问静态字段。

* 静态变量与类无关
* 所有类实例共享一个静态变量